## 控制结构

在上一节中，我们的代码在汇编中一直按照顺序执行下去。那么如何控制代码的执行呢？这就是今天的内容。

### 条件码

CPU还有一组**单个位**的**条件码（condition code）寄存器**，也可以叫**状态寄存器**。用于描述最近的算数操作。

条件码有一下这些：

![](https://lsky.ooooyasumi.com/i/2024/11/19/673c6f94ca58e.png)

CF是无符号数的进位标志 ZF是为0的标志 SF是符号位标志 OF是有符号数的溢出标志

下面要讲的两个指令是设置条件码的指令

注：以q结尾的指令是64位的指令

#### Compare

![image-20241119190310191](https://lsky.ooooyasumi.com/i/2024/11/19/673c706fd85a1.png)

cmp和减法相似，但是他不会对操作数和结果做操作。只是设置在这个减法中的条件码。

#### Test

![](https://lsky.ooooyasumi.com/i/2024/11/19/673c71a80716e.png)

用于检测一个数的状态。但是有两个输入的操作数。

两个数会进行逻辑与的操作。如果要检测一个数的状态，就将两个操作数填成一样的。

#### Set

我们一般不直接读取条件码的值，而是通过一些指令将条件码的值传送到其他地方。

这就是set命令要做的事情。注意，set命令后的后缀**不是操作数的大小**，而是各种不同的条件。

![image-20241119191614128](https://lsky.ooooyasumi.com/i/2024/11/19/673c7384432fe.png)

![image-20241119193439706](https://lsky.ooooyasumi.com/i/2024/11/19/673c77d54c1d9.png)

16个整数寄存器的低1字节都可以被调用。可以被设置成0或者1。

一个用set操作符的例子：

![image-20241119193948674](https://lsky.ooooyasumi.com/i/2024/11/19/673c7907a0e85.png)

第一条指令是取这两个数做比较（设置条件码）

第二条指令是读取条件码并赋值到寄存器

第三条指令movzbl %al, %eax是设置剩余的字节为0。movzbl指令是对8位**零扩展**到32位。具体实现是：将一个单字节（8bit）的数扩展到双字（32bit）。低8位保持不变，剩余24位填充0。

注意：在64位中，如果任意计算结果是32位，那么这个寄存器的**剩余32位会被设置为0**。而其他的并不会，比如操作一个两字节的数，剩余的部分不变。（AMD在32位扩展到64位时设置的逆天规则）

### 条件语句

#### 跳转指令（Jump）

用Jump指令实现条件语句是一种**古老的方法**。

跳转指令是一种**条件控制语句**。

跳转语句有两种，一种是无条件跳转，一种是有条件跳转。

![image-20241119195718312](https://lsky.ooooyasumi.com/i/2024/11/19/673c7d1fb3c05.png)

下面给出一个例子：

![image-20241119200600921](https://lsky.ooooyasumi.com/i/2024/11/19/673c7f2beae0f.png)

可以看到c语言中的条件语句在汇编中变成了跳转语句。但是如果是左边的代码直接扔给GCC编译的话，并不会产生右边的效果。这里是强制告诉GCC不要使用条件传送语句才能输出使用jump语句的汇编代码。

可以用goto语句把c语言写得类似汇编语言。我们可以用c语言**描述汇编语言的实现**。

![image-20241119200621503](https://lsky.ooooyasumi.com/i/2024/11/19/673c7f420932a.png)

	#### 条件传送语句（Conditional Move Instructions）

现在更多采用条件传送语句实现条件语句。GCC也更倾向于使用条件传送语句。因为jump语句**会打破程序的控制流**。这会很大程度上减慢程序运行的速度。条件传送语句的优势在于它不会打破程序的控制流，而是根据条件直接在寄存器之间传送数据。

> 具体为什么可以看CSAPP P146

![image-20241119204724695](https://lsky.ooooyasumi.com/i/2024/11/19/673c892169674.png)

条件传送语句会把两个值都计算一遍。但是会根据条件传送数据。

正因为会把两个值都算一遍，所以在某些情况，比如两个计算都很复杂的时候，编译器还是会采用jump语句。

但是编译器**更加倾向于选择条件传输指令**。

![image-20241119211405916](https://lsky.ooooyasumi.com/i/2024/11/19/673c8f1f6dd72.png)

以上是条件传送指令的表，可以发现他们都以“c”开头。

### 循环结构

循环结构和条件语句一样。也可以使用跳转实现。我们一样使用c语言描述它的实现过程。

#### do while循环

我们先来看do while语句的实现。

![image-20241119212257270](https://lsky.ooooyasumi.com/i/2024/11/19/673c9132e2029.png)

每次做完了语句内的内容会执行判断，判断会决定是否继续执行。

#### while循环

实现while循环有两种方式：

![image-20241119212008300](https://lsky.ooooyasumi.com/i/2024/11/19/673c908a5d3c8.png)

第一种方式就是在do while的基础上，在最开始添加了一个goto语句到测试，先执行判断。

![image-20241119212633277](https://lsky.ooooyasumi.com/i/2024/11/19/673c920b88143.png)

第二种方式就是将判断移动到最开始。如果不满足条件直接跳过循环语句。如果进入了循环语句，在每次执行结束后会再判断一次是否执行下一次。一共有两个条件语句。这个方式就是**在do while语句前面**加上一条判断语句。

#### for循环

for循环的实现就是转化为while循环。实际上for循环和while循环基本一样，就是在c语言中的书写方式不同。

![image-20241119213925484](https://lsky.ooooyasumi.com/i/2024/11/19/673c950fb01e0.png)

### switch语句

![](https://lsky.ooooyasumi.com/i/2024/11/19/673c9785b2fcb.png) 

实现switch语句用了一种叫做**跳转表**的结构。这是一种类似数组的数据结构。使用跳转表就不用挨个遍历了，执行switch语句时间和case数量无关。编译器会根据case的数量和值的跨度范围来选择**是否使用跳转表**。

![image-20241119215300202](https://lsky.ooooyasumi.com/i/2024/11/19/673c983e56f8d.png)

跳转表是从第一个数到最后一个数**都会建立表格**，而不是中间没有的就空缺。所以当跨度很大的时候，编译器不会建立跳转表，转而使用if-else语句。

如果在c语言中从非0的数，比如负数或者很大的数开始。编译器会给他添加一个**偏置量**，让这个索引在汇编中从0开始。

下面是一个switch语句的汇编实现。

![image-20241119215623783](https://lsky.ooooyasumi.com/i/2024/11/19/673c990bf012d.png)

一开始进行ja是先判断是否是default情况，如果不是再进行索引。

下表是实际的跳转表的样子。

![image-20241119220403999](https://lsky.ooooyasumi.com/i/2024/11/19/673c9ad5644fc.png)

汇编使用jmp跳转到对应标签。