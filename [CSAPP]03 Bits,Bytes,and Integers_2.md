## 整形的运算

### 无符号数加法

![image-20241114171926441](https://lsky.ooooyasumi.com/i/2024/11/14/6735c0a095523.png)

实际上结果是u+v取2<sup>w</sup>的模

### 有符号补码的加法

![image-20241114172358834](https://lsky.ooooyasumi.com/i/2024/11/14/6735c1b15e84b.png)

有无符号数相加结果相同

 ![image-20241114173030930](https://lsky.ooooyasumi.com/i/2024/11/14/6735c338d8025.png)

正溢出变成负数，负溢出变成正数 

![image-20241114173454527](/Users/ooooyasumi/Library/Application Support/typora-user-images/image-20241114173454527.png)

太小了会变成正，太大变负

### 无符号乘法

![image-20241114180415998](https://lsky.ooooyasumi.com/i/2024/11/14/6735cb2280968.png)

按理来说，储存两个w字长乘积的整形需要w<sup>2</sup>位储存

但我们不能无限地增大字长，所以溢出**直接截断**

### 有符号非补码乘法

![](https://lsky.ooooyasumi.com/i/2024/11/14/6735cb55129e3.png)

### 有符号补码乘法

![image-20241114235152193](https://lsky.ooooyasumi.com/i/2024/11/14/67361c99e2d5c.png)

使用移位操作代替乘法操作。左移位一次代表乘2

### 除法

使用移位操作符完成

### 移位操作符

<<、>>是左移操作符和右移操作符

移位分为两种操作

- 逻辑移位
- 算术移位

这两种移位**不能从符号上区分**，具体由操作数决定

操作数是无符号数->逻辑移位

操作数是有符号数（或者是负数）->算数移位

> **1.逻辑移位** **操作对象：** 二进制无符号数，例如像地址。 （1）逻辑右移 特点：高位补0，低位移出。 （2）逻辑左移 特点：低位补0，高位移出。 问题探究：什么时候会发生溢出？如何判断溢出？ 如果高位移出的是1，则左移发生溢出。
>
> **2.算术移位** **操作对象:** 二进制有符号数，现代计算机中有符号数字使用**补码**表示。由于计算机不能识别正负号，而0和1恰好可以表示这两种状态。这样就将符号数字化了。 问题探究：什么时候会发生溢出？如何判断溢出？ 算术左移溢出判断：如果移出的位不等于新的符号位，则溢出。 算术右移不会发生溢出，但是如果移出的低位不为0，则可能发生数据丢失的的情况。
>
> （1）算术左移：按指定的位数向左移位，C语言中用符号 “<<” 表示。 **移出的位放在一个特殊的寄存器中，低位补0。**
>
> **算术左移可以实现的功能:** 左移n位实现乘以2^n的功能。
>
> （2）算术右移：按指定的位数向右移位，C语言中用符号 “>>” 表示。
>
> ![img](https://lsky.ooooyasumi.com/i/2024/11/15/673622a1111b9.png)
>
> 低位舍去，高位补符号位。
>
> **算术右移可以实现的功能：** 右移n位实现乘以2^(-n)的功能。
>
> （引用自https://cloud.tencent.com/developer/article/1946592）

##   为什么不消除无符号数

![image-20241115003324210](https://lsky.ooooyasumi.com/i/2024/11/15/67362655f1669.png)

![image-20241115010407952](https://lsky.ooooyasumi.com/i/2024/11/15/67362d8a975a1.png)

一个有符号数和无符号数比较大小，有符号数会被**自动转换**为无符号数。这个过程会悄然无息地发生，编译器不会报错。

在上面这个例子中，cnt是一个无符号int，无论cnt发生怎样的变化，他都可以工作。但是如果它变成了有符号数，如果发生溢出它可能会变成一个负数。而负数则会使得这个循环**永远不会工作**。一个小问题可能会产生很大的bug！

 ## 内存组织形式

> 补充：算2的n次方大小可以用近似值。2<sup>10</sup>≈10<sup>3</sup>
>
> 2<sup>47</sup>≈128×10<sup>12</sup>,也就是128TB

 ![image-20241116110108808](https://lsky.ooooyasumi.com/i/2024/11/16/67380afb5047f.png)

内存就如同一个巨型的数组，他们的地址是整形。所以64位机器有2<sup>64</sup>个地址。排开一些占用的，可以用的地址也有**2<sup>47</sup>**个。约等于**128TB**的储存大小。这已经是一个非常可观的数字了。

## 字长（word size）

![image-20241116110652537](https://lsky.ooooyasumi.com/i/2024/11/16/67380c4d9a590.png)

字长没有一个特别明确的定义。一般值默认的整形大小或者内存的地址大小。但是现在仍然有很多计算机在用32bit的整形。所以字长这个概念显得不标准。

## 端序（endian）

小端序：多字节数据的低位字节存储在内存的低地址端，而高位字节存储在内存的高地址端。

大端序：多字节数据的低位字节存储在内存的高地址端，而高位字节存储在内存的低地址端。

![image-20241116114301988](https://lsky.ooooyasumi.com/i/2024/11/16/673814c6efbaf.png)

例如上图例子，一个4byte的整形，低位数据储存在低地址。**大端序更符合直觉**。

但是，大部分计算机**更常用小端序存储**。

![image-20241116114721130](https://lsky.ooooyasumi.com/i/2024/11/16/673815ca26b27.png)

上图为使用大端序和小端序设备的清单，现在几乎只有互联网传输数据使用大端序传输。

 ![image-20241116121500643](https://lsky.ooooyasumi.com/i/2024/11/16/67381c4642372.png)

char字符类型的储存顺序跟端序没有关系。因为char是一个一个小的1Byte组成的，而**不是一个多字符数据类型**。

## 一些练习题

![image-20241116124015282](https://lsky.ooooyasumi.com/i/2024/11/16/6738223047d1c.png)

![image-20241116124008527](https://lsky.ooooyasumi.com/i/2024/11/16/6738222919ca5.png)

答案：错

当无符号和有符号作比较时，有符号会被转换为无符号。而-1的二进制是32个1。转换为无符号数就是UMax。所以不会有ux大于-1。本题错。

![image-20241116124202221](https://lsky.ooooyasumi.com/i/2024/11/16/6738229ada975.png)

答案：上面对，下面错

所有补码整数可以转换为负数，但是负数有一个：TMin不能转换为正数。

![image-20241116124304383](https://lsky.ooooyasumi.com/i/2024/11/16/673822d947b9b.png)

所以当x为TMin时，-x不能被表示，会造成溢出。