

## 内存布局

![image-20241122082838036](https://lsky.ooooyasumi.com/i/2024/11/22/673fd0eaeed74.png)

在电脑看来，内存就是一块很大的数组，我们也可以这样看。但是实际上内存的实现方式很有趣，采用了一种叫做虚拟内存的技术，我们在后面的章节可以探讨。

> 内存的四个区：
>
> **代码区（Text Segment）**：用于存放程序的机器代码，通常是只读的，用于存放程序的执行代码。
>
> **数据区（Data Segment）**：用于存放程序中已经初始化的全局变量、静态变量、常量等数据。
>
> **堆区（Heap）**：用于存放动态分配的内存，程序员可以在程序运行时根据需要进行动态分配和释放。
>
> **栈区（Stack）**：用于存放函数的参数值、局部变量的值以及函数的返回地址等，由编译器自动分配和释放。

我们可以看到栈从内存的最高地址处向下延伸。栈通常有8M。

![image-20241122091003312](https://lsky.ooooyasumi.com/i/2024/11/22/673fd9ed94876.png)

我们声明了几个变量、很大的数组、和malloc手动分配内存

![image-20241122091128444](https://lsky.ooooyasumi.com/i/2024/11/22/673fda4346861.png)

我们会发现：全局变量在数据区，函数在代码区，局部变量在栈区，而手动分配内存在堆区。

但是堆有**两个延伸方向**。从上方和下方向中间延伸，中间的空白区域是没有被使用的区域。如果堆两个方向相遇，malloc返回0.

## 缓冲区溢出

### 内存越界引用

![image-20241122092622214](https://lsky.ooooyasumi.com/i/2024/11/22/673fddc02bbbb.png)

我们创建一个结构体，结构体中有一个数组。我们增大数组的索引，会发现编译器没有报错，反而正常运行。但是数组后的数据d被污染了。所以在C中溢出造成错误是一件很简单的事情。

### 字符串越界引用

![image-20241122103029143](https://lsky.ooooyasumi.com/i/2024/11/22/673fecc7e616b.png)

上面是库函数**gets**，它用于将输入的数据写入字符串中。

写入的终止条件是：找/n字符串结尾。所以**如果找不到/n**，它就会写超过字符串内存分配大小的数据，**造成数据污染**。

目前gets()函数已经被移除，使用fgets()代替

同理，strcpy()、scans()等函数都可能造成缓冲区溢出风险。

下面给出一个例子：

![image-20241122105441344](https://lsky.ooooyasumi.com/i/2024/11/22/673ff274944cc.png)

echo函数的作用就是输入一个字符串，将它输出出来。

这个函数在输入23个字符进去功能非常正常，但是一旦输入24个字符以上，就会返回一个Segmentation Fault（段错误）

![image-20241122112209638](https://lsky.ooooyasumi.com/i/2024/11/22/673ff8e376628.png)

可以看到我们只给函数设置了长度为4的缓冲区，但是编译器为我们开辟了24byte的空间。

call_echo红色的字是call_echo的返回地址

![image-20241122112059181](https://lsky.ooooyasumi.com/i/2024/11/22/673ff89d161c0.png)

缓冲区分配了24byte的空间，可以装23个字符，还有一个是字符串的结尾/0（00）

![image-20241122112237716](https://lsky.ooooyasumi.com/i/2024/11/22/673ff8ff580f9.png)

当输入24个字符以上，溢出的数据会破坏返回函数的地址。这将导致**函数不会得到返回值**。

这个错误可能会使程序**错误地运行**，但是不会崩溃。错误就这么静悄悄地发生了……

## 代码注入攻击

代码注入攻击利用了缓冲区溢出。

攻击者需要构造一个输入，使长度超过目标缓冲区的容量，改变**函数返回地址**，让计算机执行自己精心编写的恶意代码

![image-20241123151642328](https://lsky.ooooyasumi.com/i/2024/11/23/6741816159df7.png)

> 补充：蠕虫与病毒的区别
> ![image-20241123160055376](https://lsky.ooooyasumi.com/i/2024/11/23/67418bb8c8bb2.png)

## 对抗缓冲区溢出攻击

### 避免使用会造成缓冲区溢出的代码

比如get()函数可以换成gets()函数

gets()有一个参数是最多读取多少字节的数字，超过这个数字会将其截断。

![image-20241123160620927](https://lsky.ooooyasumi.com/i/2024/11/23/67418cfe0e348.png) 

### 系统等级的防御

#### 栈随机化（ASLR）

Address Space Layout Randomization，地址空间布局随机化。

每次程序运行的时候代码地址都是随机的，所以基本不可能知道攻击者注入的代码运行在什么地方了。

例子：

![image-20241123161833240](https://lsky.ooooyasumi.com/i/2024/11/23/67418fda7b8f7.png)

写了一段程序，声明了局部变量、全局变量、函数、自己在堆区malloc的变量。

这是程序运行多次后的结果：

![image-20241123161934966](https://lsky.ooooyasumi.com/i/2024/11/23/674190182e542.png)

我们发现local（局部变量）在栈上地址的浮动差不多有1MB，堆地址也有变化。

#### 限制可执行代码区域（NX）

Nonexecutable code segments，不可执行代码段。可以被称为NX技术。

我们可以限制攻击者向系统内注入可执行代码的能力。

最近几年才更新的安全保护措施，在处理器中有三个位控制了代码是否可以被执行。具体补充如下：

> 在处理器中，常见的用于内存保护的三个关键位是：
>
> 1. **Supervisor Mode Execution Protection (SMEP)**：这个位用于指示处理器是否允许在内核模式（特权模式）下执行用户模式的代码。当SMEP位被设置时，处理器会阻止内核模式下执行用户模式的代码，这有助于防止恶意代码执行。
> 2. **Supervisor Mode Access Protection (SMAP)**：这个位用于控制内核模式对用户模式地址空间的访问权限。当SMAP位被设置时，内核模式的代码将无法直接访问用户模式的内存，从而增加了系统的安全性。
> 3. **NX (No-eXecute)**：这个位用于控制内存页面是否可以执行代码。当NX位被设置时，处理器会阻止在标记为不可执行的内存页面上执行代码，从而防止恶意代码注入和执行。
>
> 这些位的设置可以有效地增强系统的安全性，防止恶意代码的执行和内存相关的攻击。这些特性通常与操作系统和应用程序的安全机制结合使用，共同保护系统免受恶意软件和攻击的威胁。

更多的内容可以看CSAPP P201

#### 栈破坏检测（Canary）

Stack Canaries

> Canary是金丝雀的意思。在以前的矿井工人会将金丝雀带下矿井，因为金丝雀对毒性非常敏感，如果矿井下有甲烷，金丝雀会停止鸣叫甚至死亡，矿井工人看到这个信号就会马上撤离。

我们没有办法防止对数组的越界写入，但是在发生了越界写入后，我们可以检测它并进一步采取安全措施。

在局部缓冲区与栈状态中插入一个**金丝雀值**（canary），也可以叫做**哨兵值**（guard value）。

![image-20241123171205625](https://lsky.ooooyasumi.com/i/2024/11/23/67419c6720540.png)

canary值是每次运行程序随机生成的，攻击者没有简单的方法知道这个值。它检测如果在程序运行时canary值被改变了，那么将会终止程序运行。

在GCC中，程序会判断我们写的代码是否会容易产生栈溢出问题，并为我们自动插入这样的canary值与检测程序。

事实上，在前面的缓冲区溢出的演示代码编译时，加入了“-fno-stack-protector”指令强制编译器不产生canary值才能获得。

### 新的手段

新的安全手段也会带来新的攻击技术。

现在有一种新的攻击技术是Return-Oriented Programming，ROP，面向返回编程。

它绕过数据执行保护（Data Execution Prevention，DEP）和代码注入防御机制，以执行恶意代码。ROP攻击通常用于利用栈溢出等漏洞，但与传统的代码注入攻击不同，它不会将完整的恶意代码插入到受攻击程序的内存中。

ROP攻击可以绕过ASLR和NX。

> 在ROP攻击中，攻击者会利用程序中已经存在的代码片段（称为“gadgets”），这些片段通常是已编译的可执行代码中的短序列，而不是完整的恶意代码。攻击者会将这些片段串联起来，形成一系列“gadget链”，通过连续执行这些“gadgets”来实现其恶意目的。因为这些“gadgets”是程序本身合法的代码片段，所以可以绕过DEP等防御机制。
>
> ROP攻击的实质是在程序的内存空间中寻找已存在的代码片段，然后将它们组合成一种新的“代码路径”，通过这种方式来执行恶意操作，例如绕过安全检查、获取权限等。由于ROP攻击不需要向内存中注入完整的恶意代码，因此相对于传统的代码注入攻击更难被检测和防御。

例如这个例子：

![image-20241123173917808](https://lsky.ooooyasumi.com/i/2024/11/23/6741a2cb2c81e.png)

这两行的代码，从中间截断，从48到c3又可以得到一个新的代码，这可以被黑客利用。使用系统中合法存在的代码造成问题。

c3在汇编中是ret的16进制书写。

![image-20241123174214368](https://lsky.ooooyasumi.com/i/2024/11/23/6741a377a5bdb.png)

如果在缓冲区填充的是已有的代码地址，并且每条代码的末尾都有ret。那么就可以控制返回地址，让返回地址是下一条gadget的地址，实现小片段的连续执行，使用已有的合法代码完成攻击。

但是canary仍然会检测到缓冲区溢出。canary仍然是一种非常安全的技术。

## 联合体

联合体的声明和结构体很像。

![image-20241123175713196](https://lsky.ooooyasumi.com/i/2024/11/23/6741a6fc11357.png)

> "联合体"（Union）是一种在编程语言中常见的数据结构，用于在同一块内存空间中存储不同类型的数据，但每次只能使用其中一种数据类型。在C语言中，联合体允许在相同的内存位置存储不同类型的数据，但只能同时访问其中一种类型的数据。
>
> 以下是联合体的一些特点和用途：
>
> ### 特点：
>
> 1. **共享内存**：联合体的成员共享同一块内存空间，不同成员的值共享相同的内存地址。
> 2. **大小取决于最大成员**：联合体的大小取决于最大的成员的大小。
> 3. **只能同时访问一个成员**：在任意时刻，只能访问联合体中的某一个成员，访问其他成员会导致数据被覆盖。
>
> ### 用途：
>
> 1. **内存节省**：联合体可用于节省内存空间，特别是在需要存储多种类型数据但每次只需访问其中一种的情况下。
> 2. **类型转换**：通过联合体可以实现类型转换，即将同一块内存以不同的方式解释为不同的数据类型。
> 3. **位操作**：联合体也可用于进行位操作，如位域的处理。

一个联合体里面会有多种数据类型，但是它只会开辟一个空间：最大数据类型的空间。每次使用联合体都只能使用一种类型。

所以一个联合体的用处可以实现一种新的类型转换：直接转换。强制类型转换是寻找相近的值，这改变了数据的位。 

![image-20241123180649628](https://lsky.ooooyasumi.com/i/2024/11/23/6741a93b1999c.png)