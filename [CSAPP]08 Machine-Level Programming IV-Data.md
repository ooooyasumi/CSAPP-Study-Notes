## 数组

### 数组的基本原则与指针运算

#### 一维数组

![image-20241121134615259](https://lsky.ooooyasumi.com/i/2024/11/21/673ec929b41b8.png)

数组的存储空间就是在内存中的一连串区域。

![image-20241121135003338](https://lsky.ooooyasumi.com/i/2024/11/21/673eca0dbed8f.png)

我们都知道在C中，数组名就是数组的首地址。我们可以采用val[x]的方式存取这个数组的第x+1个元素。

在上面的例子中：

- val[4]：数组的第五个元素的值
- val：数组的首元地址x
- val+1：数组的第二个元素地址x+4
- &val[2]：数组的第三个元素地址x+8
- val[5]：数组的第六个元素值，这个数组只有五个元素，所以这里是在内存中存在数组后面的一个随机的值
- *(val+1)：数组的第二个元素的值
- val+i：数组的第i+1个元素地址x+4i

所以可以总结出：当我们在数组名（首地址）上加减一个数字，编译器会为我们**缩放**数组中元素的大小，在真正的地址上加减一个元素的大小值，达到可以简便访问数组元素的效果。

注意：调用数组**没有边界检查**

![image-20241121141217225](https://lsky.ooooyasumi.com/i/2024/11/21/673ecf43b4145.png)

> 补充：良好的编程风格：不要在程序里面随便设置const值。可以在文件的开头使用`#define NAME VALUE`的语法定义一个符号常量。这种放在文件开头的常量被称为魔数。
>
> 如果要创建一个数据结构，非常建议使用`typedef`定义一个自己的数据类型。如上图就定义了一个名为zip_dig的长度为ZLEN的数组作为一种数据类型。

![image-20241121142058492](https://lsky.ooooyasumi.com/i/2024/11/21/673ed14bec2ad.png)

上面是一个寻址的汇编代码，可以看到汇编中会为我们添加偏移量。

下面是一个数组循环遍历的例子：

![image-20241121142815293](https://lsky.ooooyasumi.com/i/2024/11/21/673ed301e9873.png)

上面可以看到自增代码使用一行汇编代码就解决了。

所以访问一个一维数组元素`A[x]`的真正地址计算公式是：`A+(x*k)`，k是数据类型的大小。

#### 二维数组

##### 嵌套数组

二维数组（2D array）又称嵌套数组（nested array）。就是给以数组作为元素的数组。

声明二维数组：

```c
T a[R][C]
//T是数据类型 R行数，C列数
T a[R][]
//也可以不填行号，编译器根据数据类型自行判断它需要多少列
```

下面我给出几种访问二维数组的方法：

`a`：整个二维数组的首元**地址**。

`a[0]`：是二维数组 a 的第 0 行。它表示的是一个指向这一行的指针，等价于一个一维数组。也就是第一行数组的首元**地址**。

`a[1]`：第1行的首元**地址**。

`a[0][]`：不合法的语法。

`a[0][0]`：表示这个二维数组第0行第0列的元素**值**。

`*a[0]`：表示二维数组第0行首元的**值**。*是对地址的解引用，a[0]表示第0行的首元地址，所以解引用就是它的值。

`*a`：第0行，也就是第0行的地址，也就是第0行的首地址，也就是**二维数组的首地址**。它的值和a是相同的，但是**意义不同**。a是整个二维数组的首地址，*a是第一行的首地址。

`**a`：对*a解引用，也就是二维数组的首元**值**。

`**a[0]`：不合法的语法。*a[0]是一个值，不能对值解引用。

在上面的例子中，需要理解的是**地址**和**数组**的关系。谁是二维数组的地址，谁是二维数组的元素：一维数组的地址。虽然地址可能是相同的，但是**不同的访问方法带来的意义是不同的**。在汇编代码中的**实现也是不同的**。

例子：

![image-20241121193026953](https://lsky.ooooyasumi.com/i/2024/11/21/673f19d44f66f.png)

记得在上面我们typedef了一个zip_dig类型的数组。我们可以采用这种方法声明二维数组。一维数组就是这个新数组pgh的元素。

![image-20241121193236110](https://lsky.ooooyasumi.com/i/2024/11/21/673f1a56b4d91.png)

上图为最终生成的二维数组的存储结构

所以访问一个二维数组元素`A[R][C]`的真正地址计算公式是：`A+(i*C*k)+(j*4)`，i是行数，j是列数，k是数据类型的大小

##### 多级数组

多级数组是二维数组的一种变体。

![image-20241121211127063](https://lsky.ooooyasumi.com/i/2024/11/21/673f31827f48d.png)

在声明一个多级数组时，将一个数组作为元素填入另一个数组中。

### 数组的引用

![image-20241121211719085](https://lsky.ooooyasumi.com/i/2024/11/21/673f32e4e3b4b.png)

二维数组的两种实现形式对应了底层的两种数据结构类型。

及时引用数组的代码写的一样，但是其实现完全不同。

嵌套数组使用了一次引用，而多级数组使用了两次。

### 定长数组与变长数组

![image-20241121212502880](https://lsky.ooooyasumi.com/i/2024/11/21/673f34ba4934a.png)

上面区分了定长数组和变长数组。定长数组在编译数组期间就被确定。变长数组在数组编译后被确定。

确定变长数组有两种方法：古老的方法是需要手动计算这个新数组的内存占用大小，并且使用malloc等函数手动分配内存空间。

现在的新编译器支持自动计算数组大小并自动分配。

变长数组的描述如下：

![image-20241121213418298](https://lsky.ooooyasumi.com/i/2024/11/21/673f36dd045f0.png)

![image-20241121213457600](https://lsky.ooooyasumi.com/i/2024/11/21/673f370500f4a.png)

上面对汇编代码可以看到，在函数中引用一个值使用了n。这就说明了这个数组是当`A[n][n]`出现时再动态改变的。并没有单独对它操作。

## 结构体

![image-20241122000147867](https://lsky.ooooyasumi.com/i/2024/11/22/673f596f0a416.png)

结构体就是里面装了很多种数据组合而成的一种数据类型。

![image-20241122001251078](https://lsky.ooooyasumi.com/i/2024/11/22/673f5c04ec1c8.png)

### 结构体的对齐

![image-20241122003012684](https://lsky.ooooyasumi.com/i/2024/11/22/673f6018a5dee.png)

编译器在编译结构体的时候会添加空白空间，将某些数据的头地址变为某个值K的倍数。原则是：任何K字节的基本对象的地址必须是K的倍数。

因为如果在处理器的读取中一个数据正好处于读取的边界，编译器会采取更复杂的行动避免错误，会拖慢程序。所以添加偏移量更加方便。

![image-20241122003706688](https://lsky.ooooyasumi.com/i/2024/11/22/673f61b4ac9a2.png)

即使是结尾没有对齐也会添加空白空间到8的倍数。

 ![image-20241122004445328](https://lsky.ooooyasumi.com/i/2024/11/22/673f637fa8c0f.png)

**所以**：将**大的数据放在结构体的前面**，小的数据放在后面会减少对齐添加的空白空间的数量，可以节约储存空间。