## 使用二进制的位和字节表示一切

Byte = 8bits

表示数字范围：

- 二进制：00000000-11111111
- 十进制：0-255
- 十六进制：00-FF

注：

1. 4位的bin bit转换为hex
2. 在C语言中十六进制被表示为**0x**……（……为十六进制数）![image-20241022010632444](https://lsky.ooooyasumi.com//i/2024/10/22/67168a1a871eb.png)
3. 下图为hex-dec-bin转换表

![image-20241022010648463](https://lsky.ooooyasumi.com//i/2024/10/22/67168a2b5ac37.png) 

## 不同数据类型的长度

![image-20241022011158449](https://lsky.ooooyasumi.com//i/2024/10/22/67168b607b584.png)

上图表示了32和64bit的计算机的各种数据类型的大小（单位为byte）

由于在C语言发明时的计算机子长大多出于16bit，所以一般的数据长度被设计得很小，这也反映了C语言是一门古老的语言。

本课程只考虑**64bit**机器的情况。

## 操作符介绍

### 位操作符

& 按位与 相同为1

| 按位或 有一个为1则1

^ 按位异或 相同为0

~ 按位取反

![image-20241022012031133](https://lsky.ooooyasumi.com//i/2024/10/22/67168d6027ff1.png)

#### 对比：逻辑操作符

&&,||,!都是逻辑操作符，他们通常只返回0或1。

![image-20241022013224577](https://lsky.ooooyasumi.com//i/2024/10/22/671690298924c.png)

上图的最后一行使用了逻辑运算符的提前终止功能，防止空指针的存在

### 移位操作符

<<、>>是左移操作符和右移操作符

移位分为两种操作

- 逻辑移位
- 算术移位

这两种移位**不能从符号上区分**，具体由操作数决定

操作数是无符号数->逻辑移位

操作数是有符号数->算数移位

> **1.逻辑移位** **操作对象：** 二进制无符号数，例如像地址。 （1）逻辑右移 特点：高位补0，低位移出。 （2）逻辑左移 特点：低位补0，高位移出。 问题探究：什么时候会发生溢出？如何判断溢出？ 如果高位移出的是一，则左移发生溢出。
>
> **2.算术移位** **操作对象:** 二进制有符号数，现代计算机中有符号数字使用**补码**表示。由于计算机不能识别正负号，而0和1恰好可以表示这两种状态。这样就将符号数字化了。 问题探究：什么时候会发生溢出？如何判断溢出？ 算术左移溢出判断：如果移出的位不等于新的符号位，则溢出。 算术右移不会发生溢出，但是如果移出的低位不为0，则可能发生数据丢失的的情况。
>
> （1）算术左移 算术左移：按指定的位数向左移位，C语言中用符号 “<<” 表示。 **移出的位放在一个特殊的寄存器中，低位补0。**
>
> **算术左移可以实现的功能:** 左移n位实现乘以2^n的功能。
>
> （2）算术右移 算术右移：按指定的位数向右移位，C语言中用符号 “>>” 表示。
>
> ![img](https://lsky.ooooyasumi.com//i/2024/10/22/6717127f10e71.png)
>
> **算术右移可以实现的功能：** 右移n位实现乘以2^(-n)的功能。
>
> （引用自https://cloud.tencent.com/developer/article/1946592）

## 数字的表示

### 整形

#### 有符号和无符号整形

将二进制数分别转化为有符号和无符号整形

![image-20241114003355213](https://lsky.ooooyasumi.com/i/2024/11/14/6734d4f4515ec.png)

上图是有符号和无符号整形可以表示的数据范围

![image-20241114004552211](https://lsky.ooooyasumi.com/i/2024/11/14/6734d7c10d954.png)

⬆️特征

![image-20241114004440863](https://lsky.ooooyasumi.com/i/2024/11/14/6734d77a3bfb0.png)

常见字长的两种整形范围

#### 补码的世界

现在计算机大多采用补码进行数据表示

因为正数的原反补码的二进制数都相同，所以补码仅在有符号数的负数起作用。

以下是三种码的区别：

**原码**：

- 最高位为符号位，0表示正数，1表示负数。
- 其余位表示数值的绝对值。
- 原码存在符号位冗余的问题，同一个数的正负两种表示，导致运算复杂。

**反码**：

- 负数的反码是符号位不变，其他按位取反得到的。
- 负数的反码最高位是1，但是数值部分不同于原码，而是正数的对应位取反。

**补码**：

- 负数的补码是其反码加1。
- 补码解决了原码的符号位冗余和反码的加减法规则不一致的问题，同时只有一个零表示。

**有符号数原码**：最高位为符号位，表示符号。正数是0，负数就是1。要将一个正数变成负数就直接在将高位变1。

例子：

​	正数 +3 的原码：`00000011`

​	负数 -3 的原码：`10000011`

​	反码：`11111100`（-3 的反码）

​	补码：`11111101`（-3 的补码）

不难发现：同样按位，每一位是2的i次幂。补码的最高位是**该幂的负数**，再加起来正好是这个补码表示的负数。 

所以，当最高位为1时，2的i次幂超过了低位的幂的和，则这个补码表示的数**一定是负数**。

补码的性质：

1. 最高位为1表示负数
2. 将最高位变为0后，表示一个正数，并且等于原来的这个负数加上2<sup>w-1</sup>。相同的二进制数，原码补码相差2<sup>w-1</sup>。

![image-20241114012750187](https://lsky.ooooyasumi.com/i/2024/11/14/6734e198ddaa9.png)

⬆️补码转换到原码的有符号数

这就造成了一个现象：**正数二进制不变，而负数变化大**

#### 扩展整形位数

将符号位复制到新增的空位中

![image-20241114020811953](https://lsky.ooooyasumi.com/i/2024/11/14/6734eb0d58eb7.png)

当待扩容数是负数时，扩展后的数前面都是1，转换成十六进制就是FF……

![image-20241114021040465](https://lsky.ooooyasumi.com/i/2024/11/14/6734eba215c11.png)
